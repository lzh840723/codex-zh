#!/usr/bin/env bash
# 中文输入 → 英文与 Codex 交互 → 中文输出（保护代码块）
# - 管理/查询子命令直通：resume/status/logs/list/runs/env/stop/kill/ps/inspect/history
# - FORCE_TRANSLATE=1 时，强制把 Codex 输出翻译为中文（即使是直通子命令）
# - 支持：codex exec / codex cloud exec
# - 依赖：translate-shell (trans)、python3
# - 可选：CODEX_CMD 指定 codex 可执行名（默认 "codex"）

set -euo pipefail

# ---------- 依赖检查 ----------
CODEX_CMD="${CODEX_CMD:-codex}"
if ! command -v "$CODEX_CMD" >/dev/null 2>&1; then
  echo "未找到可执行命令：$CODEX_CMD（可设置环境变量 CODEX_CMD 或安装官方 codex CLI）" >&2
  exit 127
fi
if ! command -v trans >/dev/null 2>&1; then
  echo "未找到 translate-shell（命令名：trans）。请先安装：brew install translate-shell" >&2
  exit 127
fi
if ! command -v python3 >/dev/null 2>&1; then
  echo "未找到 python3，请先安装（macOS 可用 Xcode CLT 或 Homebrew）。" >&2
  exit 127
fi
if ! command -v script >/dev/null 2>&1; then
  echo "未找到 /usr/bin/script（macOS 自带）。请确认系统存在 'script' 命令。" >&2
  exit 127
fi

# ---------- 代码块保护的 英→中 翻译 ----------
back_to_zh_protected() {
python3 - <<'PY'
import os, re, subprocess, sys

ENGINE = os.environ.get('TRANS_ENGINE', 'auto').lower()

def try_trans(engine: str, s: str) -> str:
    if engine == 'libre':
        url = os.environ.get('LIBRE_URL', 'https://libretranslate.com/translate')
        # 依赖 jq; 若缺失则直接返回原文
        cmd = (
            "jq -Rs '{q:., source:" + '"en", target:"zh"' + "}' <<'EOF'\n" + s + "\nEOF | "
            "curl -s -H 'Content-Type: application/json' -d @- " + url + " | jq -r '.translatedText'"
        )
    else:
        flag = '' if engine in ('', 'auto', 'google') else f"-e {engine} "
        cmd = f"trans {flag}-b -s en -t zh <<'EOF'\n" + s + "\nEOF"
    try:
        out = subprocess.check_output(["bash","-lc", cmd], text=True)
        return out.strip()
    except Exception:
        return ''

def run_trans(s: str) -> str:
    # 优先用户指定引擎
    order = [ENGINE] if ENGINE not in ('', 'auto') else []
    # 默认顺序：auto(google) -> bing -> deepl -> libre
    order += ['auto', 'bing', 'deepl', 'libre']
    seen = set()
    for eng in order:
        if eng in seen:
            continue
        seen.add(eng)
        out = try_trans(eng, s)
        if out:
            return out
    return s

def clean_text(s: str) -> str:
    # Remove CSI sequences: ESC [ ... ] with intermediates
    s = re.sub(r"\x1B\[[0-?]*[ -/]*[@-~]", "", s)
    # Remove OSC: ESC ] ... BEL or ST
    s = re.sub(r"\x1B\][^\a]*(?:\a|\x1b\\)", "", s)
    # Remove single-char escapes: ESC followed by one 7-bit char
    s = re.sub(r"\x1B[@-Z\\-_]", "", s)
    # Remove backspaces and preceding char
    prev = None
    while prev != s:
        prev = s
        s = re.sub(r"[^\n]\x08", "", s)
    # Normalize CR
    s = s.replace("\r", "")
    # Collapse many blank lines
    s = re.sub(r"\n{3,}", "\n\n", s)
    return s

txt = clean_text(sys.stdin.read())
blocks = []
def keep(m):
    blocks.append(m.group(0))
    return f"§§BLOCK{len(blocks)-1}§§"
masked = re.sub(r"```.*?```", keep, txt, flags=re.S)

# 分段翻译，避免长文本导致 translate-shell 返回空
chunks = []
buf = masked
MAX = 3000
while len(buf) > MAX:
    cut = buf.rfind("\n\n", 0, MAX)
    if cut < 0:
        cut = MAX
    chunks.append(buf[:cut])
    buf = buf[cut:]
if buf:
    chunks.append(buf)

out = '\n'.join(run_trans(c) for c in chunks)

def putback(m):
    i = int(m.group(1))
    return blocks[i] if 0 <= i < len(blocks) else m.group(0)

final = re.sub(r"§§BLOCK(\\d+)§§", putback, out)
print(final if final.strip() else (txt or '（无可译内容）'))
PY
}

# ---------- 实时英→中翻译（保护代码块；按块增量翻译，输出到 stderr） ----------
live_translate_protected() {
python3 - <<'PY'
import os, re, subprocess, sys, time, select

def clean_text(s: str) -> str:
    s = re.sub(r"\x1B\[[0-?]*[ -/]*[@-~]", "", s)
    s = re.sub(r"\x1B\][^\a]*(?:\a|\x1b\\)", "", s)
    s = re.sub(r"\x1B[@-Z\\-_]", "", s)
    prev = None
    while prev != s:
        prev = s
        s = re.sub(r"[^\n]\x08", "", s)
    s = s.replace("\r", "")
    return s

def mask_blocks(text):
    blocks = []
    def keep(m):
        blocks.append(m.group(0))
        return f"§§BLOCK{len(blocks)-1}§§"
    masked = re.sub(r"```.*?```", keep, text, flags=re.S)
    return masked, blocks

def unmask(text, blocks):
    def putback(m):
        idx = int(m.group(1))
        return blocks[idx] if 0 <= idx < len(blocks) else m.group(0)
    return re.sub(r"§§BLOCK(\d+)§§", putback, text)

BUF_MAX = 1800
IDLE_SEC = 0.8
buf = ""
last = time.time()

def flush():
    global buf, last
    data = buf.strip()
    buf = ""
    last = time.time()
    if not data:
        return
    masked, blocks = mask_blocks(data)
    # 引擎选择同上：优先用户设置，其次 auto->bing->deepl->libre
    import os
    os.environ.setdefault('TRANS_ENGINE', os.environ.get('TRANS_ENGINE','auto'))
    def tr_once(s):
        import subprocess
        from subprocess import CalledProcessError
        def t(engine, s):
            if engine == 'libre':
                url = os.environ.get('LIBRE_URL', 'https://libretranslate.com/translate')
                cmd = ("jq -Rs '{q:., source:\"en\", target:\"zh\"}' <<'EOF'\n" + s + "\nEOF | "
                       "curl -s -H 'Content-Type: application/json' -d @- " + url + " | jq -r '.translatedText'")
            else:
                flag = '' if engine in ('', 'auto', 'google') else f"-e {engine} "
                cmd = f"trans {flag}-b -s en -t zh <<'EOF'\n" + s + "\nEOF"
            try:
                o = subprocess.check_output(["bash","-lc", cmd], text=True)
                return o.strip()
            except Exception:
                return ''
        pref = os.environ.get('TRANS_ENGINE','auto').lower()
        order = [pref] if pref not in ('', 'auto') else []
        order += ['auto','bing','deepl','libre']
        seen=set()
        for eng in order:
            if eng in seen: continue
            seen.add(eng)
            o=t(eng,s)
            if o:
                return o
        return s
    out = tr_once(masked)
    sys.stderr.write("\n【译】" + unmask(out, blocks).rstrip() + "\n")
    sys.stderr.flush()

fd = sys.stdin.fileno()
while True:
    r,_,_ = select.select([fd], [], [], IDLE_SEC)
    if r:
        chunk = sys.stdin.read(4096)
        if not chunk:
            break
        chunk = clean_text(chunk)
        buf += chunk
        if len(buf) >= BUF_MAX or buf.endswith("\n\n"):
            flush()
    else:
        if buf:
            flush()
flush()
PY
}

# ---------- 中→英 翻译 ----------
to_en() { trans -b -s zh -t en <<<"$1"; }

# ---------- 直通白名单（管理/查询型子命令） ----------
PASSTHRU_CMDS=("status" "logs" "list" "runs" "env" "stop" "kill" "ps" "inspect" "history")

# ---------- 使用 PTY 执行并清理 ANSI ----------
codex_with_pty() {
  # 构造安全可复用的 shell 字符串（避免引号问题）
  # 直接以 command 方式执行，避免 -c 解析差异；继承当前环境 PATH
  /usr/bin/script -q /dev/null "$CODEX_CMD" "$@" 2>&1
}

# ---------- resume: 交互显示英文原样，同时落盘，结束后输出中文译文 ----------
resume_with_capture() {
  local stamp log_dir tlog zh_file
  stamp=$(date +%Y%m%d-%H%M%S)
  log_dir="${CZX_LOG_DIR:-$HOME/Library/Logs/codex-zh}"
  mkdir -p "$log_dir"
  tlog="$log_dir/typescript-$stamp.log"
  zh_file="$log_dir/zh-$stamp.txt"
  if [ "${LIVE_TRANSLATE:-0}" = "1" ]; then
    echo "[codex-zh] LIVE translate enabled; writing Chinese to log. View with: codex-zh follow (or set LIVE_TO_STDERR=1)" 1>&2
    : > "$tlog"
    (
      tail -n +1 -f "$tlog" \
        | live_translate_protected \
        | { if [ "${LIVE_TO_STDERR:-0}" = "1" ]; then tee -a "$zh_file" 1>&2; else cat >> "$zh_file"; fi; }
    ) &
    local tpid=$!
    /usr/bin/script -q "$tlog" "$CODEX_CMD" "$@"
    local st=$?
    sleep 0.2
    kill "$tpid" >/dev/null 2>&1 || true
    wait "$tpid" 2>/dev/null || true
    # 结束后生成完整中文回放并落盘
    sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' "$tlog" | tr -d '\r' | back_to_zh_protected | tee "$zh_file" >/dev/null || true
    ln -sf "$tlog" "$log_dir/last.typescript.log" 2>/dev/null || true
    ln -sf "$zh_file" "$log_dir/last.zh.log" 2>/dev/null || true
    echo "[codex-zh] Saved English log: $tlog" 1>&2
    echo "[codex-zh] Saved Chinese log: $zh_file" 1>&2
    return $st
  else
    /usr/bin/script -q "$tlog" "$CODEX_CMD" "$@"
    local st=$?
    printf '\n===== 中文译文（会话回放）====='
    printf '\n(提示：上方是英文交互原文；以下为自动翻译，代码块原样保留)\n\n'
    sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' "$tlog" | tr -d '\r' | back_to_zh_protected | tee "$zh_file" || true
    ln -sf "$tlog" "$log_dir/last.typescript.log" 2>/dev/null || true
    ln -sf "$zh_file" "$log_dir/last.zh.log" 2>/dev/null || true
    echo "[codex-zh] Saved English log: $tlog" 1>&2
    echo "[codex-zh] Saved Chinese log: $zh_file" 1>&2
    return $st
  fi
}

# ---------- FORCE_TRANSLATE：强制翻译 Codex 输出 ----------
# 若设置 FORCE_TRANSLATE=1 且无 stdin（不吃提示词），则用 PTY 包裹执行，再去 ANSI，并把英文输出翻译为中文
if [ "${FORCE_TRANSLATE:-0}" = "1" ] && [ -t 0 ] && [ $# -gt 0 ]; then
  set +e
  codex_with_pty "$@" \
    | sed -E 's/\x1B\[[0-9;]*[A-Za-z]//g' \
    | back_to_zh_protected
  st=${PIPESTATUS[0]:-0}
  set -e
  exit $st
fi

# ---------- 自动翻译：当子命令为 resume 时（无需设置 FORCE_TRANSLATE） ----------
if [[ $# -gt 0 ]]; then
  if [[ "$1" == "resume" ]]; then
    resume_with_capture "$@"
    exit $?
  elif [[ "$1" == "cloud" && "${2:-}" == "resume" ]]; then
    resume_with_capture "$@"
    exit $?
  fi
fi

# ---------- 默认直通：管理/查询子命令（无 stdin 时不翻译） ----------
if [ -t 0 ] && [[ $# -gt 0 ]]; then
  # 便捷查看：codex-zh follow  —— 实时查看最近会话的中文日志
  if [[ "$1" == "follow" ]]; then
    log_dir="${CZX_LOG_DIR:-$HOME/Library/Logs/codex-zh}"
    zh="$log_dir/last.zh.log"
    mkdir -p "$log_dir" && : > "$zh"
    exec less -R +F "$zh"
  fi
  first="$1"
  if [[ "$first" == "cloud" && $# -gt 1 ]]; then
    second="$2"
    for s in "${PASSTHRU_CMDS[@]}"; do
      if [[ "$second" == "$s" ]]; then
        exec "$CODEX_CMD" "$@"
      fi
    done
  else
    for s in "${PASSTHRU_CMDS[@]}"; do
      if [[ "$first" == "$s" ]]; then
        exec "$CODEX_CMD" "$@"
      fi
    done
  fi
fi

# ---------- 读取输入：优先 stdin；否则把参数拼成“中文提示词” ----------
INPUT_CN=""
if [ -t 0 ]; then
  if [[ $# -gt 0 ]]; then
    # 把所有参数视为“中文提示词”；如果你想把参数保留给 codex，请改为只取 $1 等
    INPUT_CN="$*"
    set --   # 清空参数，避免把英文提示又当作参数传给 codex
  fi
else
  INPUT_CN="$(cat)"
fi

# 若依然没有中文提示（且也不是直通场景），给出用法提示
if [[ -z "$INPUT_CN" ]]; then
  cat >&2 <<'USAGE'
用法：
  echo "中文需求" | codex-zh [exec参数...]
  codex-zh "中文需求" [exec参数...]

resume（自动翻译）示例：
  codex-zh resume <RUN_ID> --search

直通（不翻译）示例（等同原生 codex）：
  codex-zh status
  codex-zh list

强制翻译直通输出（FORCE_TRANSLATE=1）：
  FORCE_TRANSLATE=1 codex-zh status

说明：
  - resume 子命令：默认用 PTY 执行并翻译（保护代码块）。
  - 有中文输入时：中文 → 英文（trans）→ codex exec/cloud exec → 英文结果回译中文。
  - 其他管理/查询子命令默认直通；设置 FORCE_TRANSLATE=1 可强制翻译其输出。
USAGE
  exit 2
fi

# ---------- 判定 exec / cloud exec ----------
SUBCMD=("exec")
if [[ "${1:-}" == "cloud" ]]; then
  shift
  SUBCMD=("cloud" "exec")
fi

# ---------- 中文 → 英文 ----------
PROMPT_EN="$(to_en "$INPUT_CN")"

# ---------- 调用 codex：优先 stdin 喂提示词；失败则走参数 ----------
set +e
RESP_EN="$(printf '%s' "$PROMPT_EN" | "$CODEX_CMD" "${SUBCMD[@]}" "$@")"
status=$?
set -e
if [[ $status -ne 0 ]]; then
  RESP_EN="$("$CODEX_CMD" "${SUBCMD[@]}" "$PROMPT_EN" "$@")"
fi

# ---------- 英文 → 中文（保护代码块） ----------
printf '%s' "$RESP_EN" | back_to_zh_protected
